#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/i2c.h>
#include <linux/cdev.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/device.h>

#define MCP9808_I2C_ADDRESS  0x18    // I2C address for MCP9808
#define MCP9808_TEMP_REG     0x05    // Temperature register
#define DEVICE_NAME "mcp9808"

static dev_t mcp9808_dev;
static struct class *mcp9808_class;

struct mcp9808_data {
    struct i2c_client *client;
    struct cdev cdev;   // Character device structure
};

// Function to read temperature from the MCP9808
static int read_temperature(struct i2c_client *client)
{
    uint8_t reg = MCP9808_TEMP_REG;
    uint8_t temp_data[2];
    int ret, temp;

    // Write register address and read two bytes of temperature data
    dev_info(&client->dev, "Reading temperature data from MCP9808\n");
    ret = i2c_master_send(client, &reg, 1);
    if (ret < 0) {
        dev_err(&client->dev, "Failed to write to MCP9808 register\n");
        return ret;
    }

    ret = i2c_master_recv(client, temp_data, 2);
    if (ret < 0) {
        dev_err(&client->dev, "Failed to read temperature data from MCP9808\n");
        return ret;
    }

    // Process the temperature data
    temp = ((temp_data[0] & 0x1F) << 8) | temp_data[1];
    if (temp_data[0] & 0x10) temp -= 256 * 16;  // Adjust for negative values if necessary

    dev_info(&client->dev, "Temperature read as %d Celsius\n", temp / 16);
    return temp / 16;  // Return temperature in Celsius
}

// Character device read function
static ssize_t mcp9808_read(struct file *file, char __user *buf, size_t count, loff_t *offset)
{
    struct mcp9808_data *data = file->private_data;
    int temperature;
    char temp_str[16];
    int len;

    dev_info(&data->client->dev, "User reading temperature from /dev/mcp9808\n");

    temperature = read_temperature(data->client);
    if (temperature < 0)
        return temperature;

    len = snprintf(temp_str, sizeof(temp_str), "%d\n", temperature);

    if (*offset >= len)
        return 0;

    if (copy_to_user(buf, temp_str, len))
        return -EFAULT;

    *offset += len;
    return len;
}

// Character device open function
static int mcp9808_open(struct inode *inode, struct file *file)
{
    struct mcp9808_data *data = container_of(inode->i_cdev, struct mcp9808_data, cdev);
    file->private_data = data;

    dev_info(&data->client->dev, "Opened /dev/mcp9808\n");
    return 0;
}

// Character device file operations
static const struct file_operations mcp9808_fops = {
    .owner = THIS_MODULE,
    .open = mcp9808_open,
    .read = mcp9808_read,
};

// Probe function for initializing the device
static int mcp9808_probe(struct i2c_client *client)
{
    struct mcp9808_data *data;
    int ret;

    dev_info(&client->dev, "Probing MCP9808 sensor\n");

    data = devm_kzalloc(&client->dev, sizeof(struct mcp9808_data), GFP_KERNEL);
    if (!data)
        return -ENOMEM;

    data->client = client;
    i2c_set_clientdata(client, data);

    // Allocate character device number
    ret = alloc_chrdev_region(&mcp9808_dev, 0, 1, DEVICE_NAME);
    if (ret < 0) {
        dev_err(&client->dev, "Failed to allocate character device region\n");
        return ret;
    }

    // Initialize and add character device
    cdev_init(&data->cdev, &mcp9808_fops);
    data->cdev.owner = THIS_MODULE;
    ret = cdev_add(&data->cdev, mcp9808_dev, 1);
    if (ret) {
        unregister_chrdev_region(mcp9808_dev, 1);
        return ret;
    }

    // Create device class in /dev
    mcp9808_class = class_create(DEVICE_NAME);
    if (IS_ERR(mcp9808_class)) {
        cdev_del(&data->cdev);
        unregister_chrdev_region(mcp9808_dev, 1);
        return PTR_ERR(mcp9808_class);
    }

    device_create(mcp9808_class, NULL, mcp9808_dev, NULL, DEVICE_NAME);

    dev_info(&client->dev, "MCP9808 temperature sensor initialized and /dev/mcp9808 created\n");
    return 0;
}

// Remove function for cleaning up the device
static void mcp9808_remove(struct i2c_client *client)
{
    struct mcp9808_data *data = i2c_get_clientdata(client);

    dev_info(&client->dev, "Removing MCP9808 temperature sensor\n");

    device_destroy(mcp9808_class, mcp9808_dev);
    class_destroy(mcp9808_class);
    cdev_del(&data->cdev);
    unregister_chrdev_region(mcp9808_dev, 1);

    dev_info(&client->dev, "MCP9808 temperature sensor and /dev/mcp9808 removed\n");
}

// I2C device ID table
static const struct i2c_device_id mcp9808_id[] = {
    { "mcp9808", 0 },
    { }
};
MODULE_DEVICE_TABLE(i2c, mcp9808_id);

// I2C driver structure
static struct i2c_driver mcp9808_driver = {
    .driver = {
        .name = "mcp9808",
    },
    .probe = mcp9808_probe,
    .remove = mcp9808_remove,
    .id_table = mcp9808_id,
    .address_list = (const unsigned short[]){ MCP9808_I2C_ADDRESS, I2C_CLIENT_END },
};

module_i2c_driver(mcp9808_driver);

MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("MCP9808 Temperature Sensor Driver with Debug Messages");
MODULE_LICENSE("GPL");

